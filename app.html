<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/png" href="logo_agrosharp.png">
    <title>Fluxo de Caixa</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f5f5f5;
        }

        .header {
            background-color: #2196F3;
            padding: 6px 20px;
            padding-bottom: 7px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        #authButton {
            display: block;              /* permite centralizar com margin */
            margin: 20px auto;           /* centraliza horizontalmente */
            font-size: 15px;
            padding: 8px 12px;
            border-radius: 4px;
            border: none;                /* remove a borda */
            color: #ffffff;
            background-color: rgb(135, 147, 160);
        }

        .balance-pai {
            padding: 2px 8px;
            padding-bottom: 4px;
            border-radius: 4px;
            color: #333;
            background-color: white;
        }

        .balance {
            font-size: 18px;
            font-weight: bold;
        }

        .balance-label {
            font-size: 13px;
            opacity: 0.9;
        }

        .filter-select {
            padding: 6px 6px;
            border: none;
            border-radius: 4px;
            background-color: white;
            color: #333;
            font-size: 14px;
            cursor: pointer;
        }

        .titulo-select{
            padding-bottom: 2px;
            font-size: 14px;
            color: rgb(255, 255, 255);
        }

        
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        table {
            width: 100%;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-collapse: collapse; /* opcional, só pra ficar mais bonito */
        }

        .table-wrapper {
            max-height: calc(100dvh - 106px);
            overflow-y: auto;
        }

        /* Cabeçalho fixo no topo da área rolável da tabela */
        .table-wrapper thead th {
            position: sticky;
            top: 0;
            background-color: #1976D2; /* reforça fundo sólido */
            z-index: 3;
        }

        .table-wrapper tbody .total-row td {
            position: sticky;
            bottom: 0;
            background-color: #e3f2fd; /* nova cor de fundo (azul clarinho, por exemplo) */
            color: #0d47a1;            /* cor do texto (opcional) */
            font-weight: 600;          /* mantém destaque */
            z-index: 3;
            border-top: 1px solid #bbdefb; /* separador visual opcional */
        }


        #table-entradas th:nth-child(2),
        #table-saidas th:nth-child(2),
        /* Coluna Valor: células (2ª coluna) */
        #table-entradas td:nth-child(2),
        #table-saidas td:nth-child(2) {
            white-space: nowrap;    /* não quebra linha */
        }


        /* Container do gráfico ocupando a área útil da tela */
        #projetosChartWrapper {
            height: calc(100dvh - 123px);
            padding: 10px;
        }

        /* Canvas preenche totalmente o wrapper */
        #projetosChart {
            width: 100% !important;
            height: 100% !important;
        }


        #projecaoChartWrapper {
            height: calc(100dvh - 123px);
            padding: 10px;
        }

        #projecaoChart {
            width: 100% !important;
            height: 100% !important;
        }

        thead {
            background-color: #1976D2;
            color: white;
        }

        th {
            padding: 12px 8px;
            text-align: left;
            font-size: 14px;
            font-weight: 600;
        }

        td {
            padding: 12px 8px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 14px;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .total-row {
            background-color: #f5f5f5;
            font-weight: bold;
        }

        .valor-positivo {
            color: #4CAF50;
        }

        .valor-negativo {
            color: #f44336;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #999;
        }

        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: white;
            display: flex;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            z-index: 3;
        }

        .tab-button {
            flex: 1;
            padding: 12px;
            border: none;
            background: none;
            color: #666;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s;
            border-top: 3px solid transparent;
        }

        .tab-button.active {
            color: #2196F3;
            border-top-color: #2196F3;
            font-weight: 600;
        }

        .tab-button:active {
            background-color: #f5f5f5;
        }

        @media (max-width: 480px) {
            th, td {
                padding: 10px 6px;
                font-size: 13px;
            }

            .header {
                padding: 6px 4px;
            }

            .balance {
                font-size: 15px;
            }

            .balance-label {
                font-size: 12px;
            }

            .titulo-select{
                font-size: 12px;
            }

            .filter-select {
                font-size: 13px;
                padding: 4px 2px;
            }

            .table-wrapper {
                max-height: calc(100dvh - 100px);
            }
            
            #projetosChartWrapper {
                height: calc(100dvh - 107px);
            }


            #projecaoChartWrapper {
                height: calc(100dvh - 107px);
            }
        }


        @media (max-height: 480px) {
            th, td {
              padding: 4px 6px;
              font-size: 13px;
            }

            .table-wrapper {
              max-height: calc(100dvh - 40px);
            }
            
            #projetosChartWrapper {
              height: calc(100dvh - 40px);
            }

            #projecaoChartWrapper {
              height: calc(100dvh - 32px);
            }
        
            .balance-pai {
              padding: 1px 8px;
            }

            .balance {
              font-size: 10px;
            }

            .balance-label {
              display: none;
            }

            .filtro-pai {
              display: flex;
            }

            .filter-select {
                padding: 1px 6px;
                font-size: 10px;
            }

            .titulo-select{
              display: none;
            }
               
            .header {
              padding: 1px 12px;
            }

            .tab-button {
              padding: 4px;
              font-size: 10px;
          }
        }

    </style>
</head>
<body>
    <div class="header">
        <div class="balance-pai">
            <div class="balance-label">Balanço</div>
            <div class="balance" id="balance">R$ 0,00</div>
        </div>
        <div class="filtro-pai">
          <div class="titulo-select">Filtro</div>
          <select class="filter-select" id="filter">
              <option value="">Todos</option>
          </select>
        </div>
        <div class="filtro-pai">
          <div class="titulo-select">Ano</div>
          <select class="filter-select" id="filter-ano">
              <option value="">Todos</option>
          </select>
        </div>
    </div>

    <div class="content">
        <button id="authButton" disabled>
            Carregando dados...
        </button>
        <div id="tab-entradas" class="tab-content active">
            <div class="table-wrapper">
                <table id="table-entradas">
                    <thead>
                        <tr>
                            <th>Data</th>
                            <th>Valor</th>
                            <th>Descrição</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div id="tab-saidas" class="tab-content">
            <div class="table-wrapper">
                <table id="table-saidas">
                    <thead>
                        <tr>
                            <th>Data</th>
                            <th>Valor</th>
                            <th>Descrição</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div id="tab-projetos" class="tab-content">
            <div class="empty-state">Em desenvolvimento...</div>
        </div>

        <div id="tab-projecao" class="tab-content">
            <div class="empty-state">Em desenvolvimento...</div>
        </div>
    </div>

    <div class="bottom-nav">
        <button class="tab-button active" data-tab="entradas">Entradas</button>
        <button class="tab-button" data-tab="saidas">Saídas</button>
        <button class="tab-button" data-tab="projetos">Projetos</button>
        <button class="tab-button" data-tab="projecao">Projeção</button>
    </div>
<script>
    /********************************************
     * CONFIGURAÇÃO - PREENCHA ESTES CAMPOS
     ********************************************/
    const CLIENT_ID   = "163634037411-2dtla9mb66kmjovrk8j3ialnk6q4rg4j.apps.googleusercontent.com";
    const API_KEY     = "AIzaSyCP839P4CNWHMYhwsvpZJVb-_k74xSyRsU";
    const SHEET_ID    = "1hjxWFmlfGXnL3UJV03zZNe7uKFwZg4GBxutsaC1Vci0";
    const SHEET_RANGE = "Página1!A:G"; // Aba e colunas onde estão: Data, Tipo, Valor, Descrição, Projeto, Conta Bancária, Data Lançamento
    
    const SHEET_PROJECAO_ID = "1vLQuPR0Mss1GPP3iU3wCcUtaXe69wqKk-U4XWBjjSpM";
    const SHEET_PROJECAO_RANGE = "Página1!A:B";
    
    const SHEET_PROJETOS_LUCRO_ID = "1auAB0FHrFk0YHTxsvblF1zZJXnG2SvlhqIn_6MZxoxE";
    const SHEET_PROJETOS_LUCRO_RANGE = "Página1!A:B";

    const DISCOVERY_DOC = "https://sheets.googleapis.com/$discovery/rest?version=v4";
    const SCOPES        = "https://www.googleapis.com/auth/spreadsheets.readonly";

  // Chave usada no localStorage para lembrar o token
  const TOKEN_STORAGE_KEY = "fluxo_caixa_gsheets_token_v1";

  /********************************************
   * ESTADO GLOBAL
   ********************************************/
  let tokenClient;
  let gapiInited = false;
  let gisInited  = false;
  let domReady   = false;

  let entradas = [];
  let saidas  = [];
  
  let projecaoSeries = [];          // { data, valor } vindo da 2ª planilha
  let projecaoChartInstance = null; // instância do Chart.js na aba Projeção
  let projecoesProjetos = {}; // { [projeto]: lucroProjetado }

  /********************************************
   * FUNÇÕES DE UI (BOTÃO + CONTEÚDO)
   ********************************************/
  function getAuthButton() {
    return document.getElementById("authButton");
  }

  function showButtonLogin() {
    const btn = getAuthButton();
    if (!btn) return;
    btn.disabled = false;
    btn.textContent = "Login";
    btn.style.cursor = 'pointer';
    btn.style.backgroundColor = 'rgb(30, 124, 225)';
  }

  function showButtonLoading() {
    const btn = getAuthButton();
    if (!btn) return;
    btn.disabled = true;
    btn.textContent = "Carregando dados...";
    btn.style.backgroundColor = 'rgb(135, 147, 160)';
  }

  function hideButton() {
    const btn = getAuthButton();
    if (!btn) return;
    btn.style.display = "none";
  }

  function hideContent() {
    // Esconde saldo e abas/tabelas até os dados carregarem
    const balance = document.getElementById("balance");
    if (balance) {
      const card = balance.closest(".card") || balance;
      if (card) card.style.color = "white";
    }
    document.querySelectorAll(".tab-content").forEach(el => {
      el.style.display = "none";
    });
  }

  function showContent() {
    // Mostra saldo e abas/tabelas após dados carregados
    const balance = document.getElementById("balance");
    if (balance) {
      const card = balance.closest(".card") || balance;
      if (card) card.style.color = "";
    }
    document.querySelectorAll(".tab-content").forEach(el => {
      el.style.display = "";
    });
  }

  /********************************************
   * UTILITÁRIOS DE TOKEN (localStorage)
   ********************************************/
  function saveTokenFromResponse(resp) {
    try {
      if (!resp || !resp.access_token) return;
      const expiresIn = resp.expires_in || 3500; // segundos
      const expiresAt = Date.now() + expiresIn * 1000;

      const stored = {
        access_token: resp.access_token,
        expires_at: expiresAt,
        token_type: resp.token_type || "Bearer",
        scope: resp.scope || SCOPES
      };

      localStorage.setItem(TOKEN_STORAGE_KEY, JSON.stringify(stored));
    } catch (e) {
      console.warn("Não foi possível salvar o token:", e);
    }
  }

  function loadValidToken() {
    try {
      const raw = localStorage.getItem(TOKEN_STORAGE_KEY);
      if (!raw) return null;

      const token = JSON.parse(raw);
      if (!token.access_token || !token.expires_at) {
        localStorage.removeItem(TOKEN_STORAGE_KEY);
        return null;
      }

      if (Date.now() >= token.expires_at) {
        localStorage.removeItem(TOKEN_STORAGE_KEY);
        return null;
      }

      return {
        access_token: token.access_token,
        token_type: token.token_type || "Bearer",
        scope: token.scope || SCOPES
      };
    } catch (e) {
      console.warn("Não foi possível ler o token salvo:", e);
      localStorage.removeItem(TOKEN_STORAGE_KEY);
      return null;
    }
  }

  function clearStoredToken() {
    try {
      localStorage.removeItem(TOKEN_STORAGE_KEY);
    } catch (e) {}
    if (window.gapi && gapi.client) {
      gapi.client.setToken(null);
    }
  }

  /********************************************
   * CARREGAR SCRIPTS EXTERNOS
   ********************************************/
  function loadScript(src, onload) {
    const s = document.createElement("script");
    s.src = src;
    s.async = true;
    s.defer = true;
    if (onload) s.onload = onload;
    document.head.appendChild(s);
  }

  // gapi.js carregado
  function gapiLoaded() {
    if (!window.gapi) {
      console.error("gapi não carregado");
      return;
    }
    gapi.load("client", async () => {
      try {
        await gapi.client.init({
          apiKey: API_KEY,
          discoveryDocs: [DISCOVERY_DOC],
        });
        gapiInited = true;

        // Aplica token salvo se existir
        const saved = loadValidToken();
        if (saved) {
          gapi.client.setToken(saved);
        }

        maybeStart();
      } catch (err) {
        console.error("Erro ao inicializar gapi:", err);
        exibirErro("Erro ao inicializar Google API.");
        showButtonLogin();
      }
    });
  }

  // Google Identity Services carregado
  function gisLoaded() {
    if (!window.google || !google.accounts || !google.accounts.oauth2) {
      console.error("Google Identity Services não carregado");
      return;
    }

    tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: CLIENT_ID,
      scope: SCOPES,
      callback: () => {}, // definido dinamicamente
    });

    gisInited = true;
    maybeStart();
  }

  /********************************************
   * INÍCIO DO FLUXO
   * - Se já tiver token válido -> carrega automaticamente.
   * - Senão -> mostra botão "Login".
   ********************************************/
  function maybeStart() {
    if (!domReady || !gapiInited || !gisInited) return;

    const saved = loadValidToken();
    hideContent();

    if (saved) {
      // Tenta carregar automaticamente com token salvo
      gapi.client.setToken(saved);
      showButtonLoading();
      carregarDados()
        .then(() => {
          hideButton();
          showContent();
        })
        .catch((err) => {
          console.error("Falha com token salvo, limpando:", err);
          clearStoredToken();
          hideContent();
          showButtonLogin();
        });
    } else {
      // Precisa logar
      showButtonLogin();
    }
  }

  /********************************************
   * FLUXO DE AUTENTICAÇÃO (CLIQUES NO BOTÃO)
   ********************************************/
  async function handleAuthClick() {
    const saved = loadValidToken();

    // 1) Se por acaso tem token válido salvo, tenta direto
    if (saved) {
      gapi.client.setToken(saved);
      showButtonLoading();
      hideContent();
      try {
        await carregarDados();
        hideButton();
        showContent();
        return;
      } catch (err) {
        console.error("Erro usando token salvo no clique:", err);
        clearStoredToken();
        hideContent();
        showButtonLogin();
        return;
      }
    }

    // 2) Fluxo normal OAuth
    if (!tokenClient) {
      exibirErro("Serviço de autenticação não inicializado.");
      return;
    }

    showButtonLoading();
    hideContent();

    tokenClient.callback = async (resp) => {
      if (resp.error) {
        console.error(resp);
        hideContent();
        showButtonLogin();
        return;
      }

      saveTokenFromResponse(resp);

      try {
        await carregarDados();
        hideButton();
        showContent();
      } catch (err) {
        console.error("Erro ao carregar dados após login:", err);
        clearStoredToken();
        hideContent();
        showButtonLogin();
      }
    };

    const existing = gapi.client.getToken();
    if (!existing) {
      tokenClient.requestAccessToken({ prompt: "consent" });
    } else {
      tokenClient.requestAccessToken({ prompt: "" });
    }
  }

  /********************************************
   * LEITURA DA PLANILHA
   ********************************************/
  async function carregarDados() {
  // 1) Planilha principal (entradas/saídas)
  const resp = await gapi.client.sheets.spreadsheets.values.get({
    spreadsheetId: SHEET_ID,
    range: SHEET_RANGE,
  });

  const values = resp.result.values || [];
  if (values.length < 2) {
    throw new Error("Nenhum dado encontrado na planilha.");
  }

  const header = values[0];
  const linhas = values.slice(1);

  const rows = linhas.map(row => {
    const obj = {};
    header.forEach((colName, idx) => {
      obj[colName] = row[idx] || "";
    });
    return obj;
  });

  processarDados(rows);

  // 2) Planilha de projeção (Data, Balanço)
  projecaoSeries = [];
  if (SHEET_PROJECAO_ID && SHEET_PROJECAO_RANGE) {
    try {
      const respProj = await gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: SHEET_PROJECAO_ID,
        range: SHEET_PROJECAO_RANGE,
      });

      const vals = respProj.result.values || [];
      if (vals.length > 1) {
        const header2 = vals[0];
        const idxData    = header2.indexOf("Data");
        const idxBalanco = header2.indexOf("Balanço");

        if (idxData !== -1 && idxBalanco !== -1) {
          projecaoSeries = vals.slice(1)
            .map(row => {
              const dataStr = (row[idxData] || "").toString().trim();
              let valStr    = (row[idxBalanco] || "").toString().trim();
              if (!dataStr || !valStr) return null;

              // Trata número brasileiro se vier como texto
              valStr = valStr.replace(/\./g, "").replace(",", ".");
              const valor = parseFloat(valStr);
              if (isNaN(valor)) return null;

              return { data: dataStr, valor };
            })
            .filter(p => p && p.data);
        }
      }
    } catch (err) {
      console.warn("Não foi possível carregar planilha de projeção:", err);
      projecaoSeries = [];
    }
  }

 // 3) Planilha de projeção de lucro por projeto (Projeto, Lucro)
  projecoesProjetos = {};
  if (SHEET_PROJETOS_LUCRO_ID && SHEET_PROJETOS_LUCRO_RANGE) {
    try {
      const respProjProj = await gapi.client.sheets.spreadsheets.values.get({
        spreadsheetId: SHEET_PROJETOS_LUCRO_ID,
        range: SHEET_PROJETOS_LUCRO_RANGE,
      });

      const vals3 = respProjProj.result.values || [];
      if (vals3.length > 1) {
        const header3 = vals3[0];
        const idxProj  = header3.indexOf("Projeto");
        const idxLucro = header3.indexOf("Lucro");

        if (idxProj !== -1 && idxLucro !== -1) {
          vals3.slice(1).forEach(row => {
            const projetoRaw = (row[idxProj] || "").toString().trim();
            let lucroStr     = (row[idxLucro] || "").toString().trim();
            if (!projetoRaw || !lucroStr) return;

            lucroStr = lucroStr.replace(/\./g, "").replace(",", ".");
            const lucro = parseFloat(lucroStr);
            if (isNaN(lucro)) return;

            projecoesProjetos[projetoRaw] = lucro;
          });
        }
      }
    } catch (err) {
      console.warn("Não foi possível carregar projeção de lucro por projeto:", err);
      projecoesProjetos = {};
    }
  }

  // 4) Atualiza gráfico de Projeção (já existia)
  atualizarGraficoProjecao();
  atualizarGraficoProjetos();

  popularFiltros();
  atualizarVisualizacao();
}

  /********************************************
   * PROCESSA ENTRADAS / SAÍDAS
   * Colunas: Data, Tipo, Valor, Descrição, Projeto,
   *          Conta Bancária, Data Lançamento (ignorada)
   ********************************************/

  const MESES_CURTOS = ["jan", "fev", "mar", "abr", "mai", "jun", "jul", "ago", "set", "out", "nov", "dez"];

  function parseDataString(dateStr) {
    if (!dateStr) return null;

    // Tenta formatos comuns: dd/mm/yyyy ou yyyy-mm-dd
    const partes = dateStr.split(/[\/\-]/);
    if (partes.length === 3) {
      let dia, mes, ano;

      if (partes[0].length === 4) {
        // yyyy-mm-dd
        ano = parseInt(partes[0], 10);
        mes = parseInt(partes[1], 10) - 1;
        dia = parseInt(partes[2], 10);
      } else {
        // dd/mm/yyyy
        dia = parseInt(partes[0], 10);
        mes = parseInt(partes[1], 10) - 1;
        ano = parseInt(partes[2], 10);
      }

      if (!isNaN(ano) && !isNaN(mes) && !isNaN(dia)) {
        return new Date(ano, mes, dia);
      }
    }

    // fallback tosco se vier em outro formato, tenta pegar yyyy-mm-dd
    const m = dateStr.match(/(\d{4})-(\d{2})-(\d{2})/);
    if (m) {
      const ano = parseInt(m[1], 10);
      const mes = parseInt(m[2], 10) - 1;
      const dia = parseInt(m[3], 10);
      return new Date(ano, mes, dia);
    }

    return null;
  }


  function extrairAno(dataStr) {
    if (!dataStr) return "";

    // Aceita formatos tipo "dd/mm/yyyy", "yyyy-mm-dd", etc.
    const partes = dataStr.split(/[\/\-]/);
    if (partes.length === 3) {
      // Se vier "dd/mm/yyyy" -> ano é a 3ª parte
      // Se vier "yyyy-mm-dd" -> ano é a 1ª parte (tratamos os dois)
      let ano = partes[2].length === 4 ? partes[2] : partes[0];
      return /^\d{4}$/.test(ano) ? ano : "";
    }

    const match = dataStr.match(/(\d{4})/);
    return match ? match[1] : "";
  }


  function processarDados(rows) {
    entradas = [];
    saidas  = [];

    rows.forEach(row => {
      const tipoBruto = (row["Tipo"] || "").toString().trim().toLowerCase();
      const data      = (row["Data"] || "").toString().trim();
      let valorStr    = (row["Valor"] || "").toString().trim();
      const descricao = row["Descrição"] || row["Descricao"] || "";
      const projeto   = row["Projeto"] || "Sem projeto";
      const conta     = row["Conta Bancária"] || row["Conta bancaria"] || row["Conta"] || "Não informado";

      if (!tipoBruto || !data || !valorStr) return;

      // Trata formato brasileiro (1.234,56)
      valorStr = valorStr.replace(/\./g, "").replace(",", ".");
      const valor = parseFloat(valorStr);
      if (isNaN(valor)) return;

      const ano = extrairAno(data);

      const item = { data, ano, valor, descricao, projeto, conta };

      if (tipoBruto.startsWith("e")) {
        entradas.push(item);
      } else if (tipoBruto.startsWith("s")) {
        saidas.push(item);
      }
    });
  }


function aplicarFiltrosCombinados(dados, filtroProjetoConta, filtroAno) {
  return dados.filter(item => {
    let okProjConta = true;
    let okAno = true;

    if (filtroProjetoConta) {
      const [tipo, valor] = filtroProjetoConta.split(":");
      if (tipo === "projeto") {
        okProjConta = item.projeto === valor;
      } else if (tipo === "conta") {
        okProjConta = item.conta === valor;
      }
    }

    if (filtroAno) {
      okAno = item.ano === filtroAno;
    }

    return okProjConta && okAno;
  });
}


  /********************************************
   * UI / RENDERIZAÇÃO
   ********************************************/
    function formatarValor(valor) {
        if (isNaN(valor)) valor = 0;

        const [inteiro, decimal] = valor.toFixed(2).split(".");
        const inteiroComPontos = inteiro.replace(/\B(?=(\d{3})+(?!\d))/g, ".");

        return "R$ " + inteiroComPontos + "," + decimal;
    }

  function renderizarTabela(tipo, dados) {
    const tbody = document.querySelector(`#table-${tipo} tbody`);
    if (!tbody) return 0;

    tbody.innerHTML = "";

    if (!dados || dados.length === 0) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td colspan="3" style="text-align: center; padding: 20px; color: #999;">
          Nenhum registro encontrado
        </td>`;
      tbody.appendChild(tr);
      return 0;
    }

    let total = 0;

    dados.forEach(item => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${item.data}</td>
        <td class="${tipo === "entradas" ? "valor-positivo" : "valor-negativo"}">
          ${formatarValor(item.valor)}
        </td>
        <td>${item.descricao}</td>
      `;
      tbody.appendChild(tr);
      total += item.valor;
    });

    const trTotal = document.createElement("tr");
    trTotal.className = "total-row";
    trTotal.innerHTML = `
      <td>Total</td>
      <td class="${tipo === "entradas" ? "valor-positivo" : "valor-negativo"}" colspan="2">
        ${formatarValor(total)}
      </td>
    `;
    tbody.appendChild(trTotal);

    return total;
  }

  function filtrarDados(dados, filtro) {
    if (!filtro) return dados;
    const [tipo, valor] = filtro.split(":");
    if (!tipo || !valor) return dados;

    if (tipo === "projeto") {
      return dados.filter(i => i.projeto === valor);
    }
    if (tipo === "conta") {
      return dados.filter(i => i.conta === valor);
    }
    return dados;
  }


  function atualizarVisualizacao() {
    const filterSelect = document.getElementById("filter");        // projeto/conta
    const filterAnoSelect = document.getElementById("filter-ano"); // ano

    const filtroProjetoConta = filterSelect ? filterSelect.value : "";
    const filtroAno = filterAnoSelect ? filterAnoSelect.value : "";

    const entradasFiltradas = aplicarFiltrosCombinados(entradas, filtroProjetoConta, filtroAno);
    const saidasFiltradas   = aplicarFiltrosCombinados(saidas,   filtroProjetoConta, filtroAno);

    const totalEntradas = renderizarTabela("entradas", entradasFiltradas);
    const totalSaidas   = renderizarTabela("saidas", saidasFiltradas);

    const balanco = totalEntradas - totalSaidas;

    const balanceElement = document.getElementById("balance");
    if (balanceElement) {
      balanceElement.textContent = formatarValor(balanco);
      balanceElement.classList.remove("valor-positivo", "valor-negativo");
      balanceElement.classList.add(balanco >= 0 ? "valor-positivo" : "valor-negativo");
    }

    // Atualiza também o gráfico de projetos com os mesmos filtros
    atualizarGraficoProjetos();
    atualizarGraficoProjecao();
  }




  function popularFiltros() {
    const filterSelect = document.getElementById("filter");        // projeto/conta
    const filterAnoSelect = document.getElementById("filter-ano"); // ano

    const todos = [...entradas, ...saidas];

    // ----- Filtro projeto/conta -----
    if (filterSelect) {
      filterSelect.innerHTML = '<option value="">Todos</option>';

      // projetos vindos do fluxo real
      const projetosSet = new Set(todos.map(i => i.projeto).filter(Boolean));

      // inclui também projetos que existem só na planilha de projeções
      if (projecoesProjetos) {
        Object.keys(projecoesProjetos).forEach(p => {
          if (p) projetosSet.add(p);
        });
      }

      const projetos = [...projetosSet].sort();
      const contas   = [...new Set(todos.map(i => i.conta).filter(Boolean))].sort();

      projetos.forEach(projeto => {
        const option = document.createElement("option");
        option.value = `projeto:${projeto}`;
        option.textContent = `Projeto: ${projeto}`;
        filterSelect.appendChild(option);
      });

      contas.forEach(conta => {
        const option = document.createElement("option");
        option.value = `conta:${conta}`;
        option.textContent = `Conta: ${conta}`;
        filterSelect.appendChild(option);
      });
    }

    // ----- Filtro ano ----- (mantém igual)
    if (filterAnoSelect) {
      filterAnoSelect.innerHTML = '<option value="">Todos</option>';

      const anos = [...new Set(
        todos
          .map(i => i.ano)
          .filter(ano => ano && /^\d{4}$/.test(ano))
      )].sort((a, b) => b - a);

      anos.forEach(ano => {
        const option = document.createElement("option");
        option.value = ano;
        option.textContent = ano;
        filterAnoSelect.appendChild(option);
      });
    }
  }

  /********************************************
  * INICIALIZAÇÃO DA UI
  ********************************************/
  function inicializarUI() {
    // Tabs
    document.querySelectorAll(".tab-button").forEach(button => {
      button.addEventListener("click", () => {
        const tabName = button.dataset.tab;

        document.querySelectorAll(".tab-button")
          .forEach(btn => btn.classList.remove("active"));
        document.querySelectorAll(".tab-content")
          .forEach(content => content.classList.remove("active"));

        button.classList.add("active");
        const tabContent = document.getElementById(`tab-${tabName}`);
        if (tabContent) tabContent.classList.add("active");
      });
    });

    // Filtro
    const filterSelect = document.getElementById("filter");
    if (filterSelect) {
      filterSelect.addEventListener("change", atualizarVisualizacao);
    }

    const filterAnoSelect = document.getElementById("filter-ano");
    if (filterAnoSelect) {
      filterAnoSelect.addEventListener("change", atualizarVisualizacao);
    }

    // Botão Login
    const btn = getAuthButton();
    if (btn) {
      btn.addEventListener("click", handleAuthClick);
      // Texto controlado pelas funções de estado (Login / Carregando dados...)
    }

    // Conteúdo começa oculto
    hideContent();
  }

  /********************************************
  * BOOTSTRAP
  ********************************************/
  document.addEventListener("DOMContentLoaded", () => {
    domReady = true;
    inicializarUI();

    // Carrega as libs do Google
    loadScript("https://apis.google.com/js/api.js", gapiLoaded);
    loadScript("https://accounts.google.com/gsi/client", gisLoaded);

    // maybeStart será chamado pelos loaders quando tudo estiver pronto
  });

  let projetosChartInstance = null;


  function calcularLucroPorProjeto(entradasFonte, saidasFonte) {
    const mapa = {};

    (entradasFonte || []).forEach(item => {
      const projeto = item.projeto || "Sem projeto";
      if (!mapa[projeto]) mapa[projeto] = { entradas: 0, saidas: 0 };
      mapa[projeto].entradas += item.valor;
    });

    (saidasFonte || []).forEach(item => {
      const projeto = item.projeto || "Sem projeto";
      if (!mapa[projeto]) mapa[projeto] = { entradas: 0, saidas: 0 };
      mapa[projeto].saidas += item.valor;
    });

    const labels = [];
    const lucros = [];

    Object.keys(mapa).forEach(projeto => {
      const totalEntradas = mapa[projeto].entradas;
      const totalSaidas   = mapa[projeto].saidas;
      const lucro         = totalEntradas - totalSaidas;

      if (totalEntradas !== 0 || totalSaidas !== 0) {
        labels.push(projeto);
        lucros.push(lucro);
      }
    });

    return { labels, lucros };
  }



  // Carrega Chart.js via CDN se ainda não carregou
  function loadChartJs(callback) {
    if (window.Chart) {
      callback();
      return;
    }
    const s = document.createElement("script");
    s.src = "https://cdn.jsdelivr.net/npm/chart.js";
    s.onload = callback;
    document.head.appendChild(s);
  }

function atualizarGraficoProjetos() {
  const tabProjetos = document.getElementById("tab-projetos");
  if (!tabProjetos) return;

  const filterSelect = document.getElementById("filter");
  const filterAnoSelect = document.getElementById("filter-ano");

  const filtroProjetoConta = filterSelect ? filterSelect.value : "";
  const filtroAno = filterAnoSelect ? filterAnoSelect.value : "";

  const entradasFiltradas = aplicarFiltrosCombinados(entradas, filtroProjetoConta, filtroAno);
  const saidasFiltradas   = aplicarFiltrosCombinados(saidas,   filtroProjetoConta, filtroAno);

  // Lucro atual por projeto (já existente)
  const { labels: labelsAtuais, lucros: lucrosAtuais } = calcularLucroPorProjeto(entradasFiltradas, saidasFiltradas);

  const lucrosAtuaisMap = {};
  labelsAtuais.forEach((proj, i) => {
    lucrosAtuaisMap[proj] = lucrosAtuais[i];
  });

  let todosProjetos;

  // identifica tipo de filtro selecionado (se houver)
  let tipoFiltro = "";
  let valorFiltro = "";
  if (filtroProjetoConta) {
    [tipoFiltro, valorFiltro] = filtroProjetoConta.split(":");
  }

  // 1) Filtro por projeto: mostra só esse projeto (se existir em qualquer fonte)
  if (tipoFiltro === "projeto" && valorFiltro) {
    const existeAtual = Object.prototype.hasOwnProperty.call(lucrosAtuaisMap, valorFiltro);
    const existeProj  = projecoesProjetos && Object.prototype.hasOwnProperty.call(projecoesProjetos, valorFiltro);

    todosProjetos = (existeAtual || existeProj) ? [valorFiltro] : [];
  }
  // 2) Filtro por conta: usa apenas projetos presentes no lucro atual filtrado
  else if (tipoFiltro === "conta") {
    todosProjetos = Object.keys(lucrosAtuaisMap).sort();
  }
  // 3) Sem filtro específico: união de atual + projetado
  else {
    todosProjetos = Array.from(
      new Set([
        ...Object.keys(lucrosAtuaisMap),
        ...Object.keys(projecoesProjetos || {})
      ])
    ).sort();
  }

  if (!todosProjetos.length) {
    tabProjetos.innerHTML = '<div class="empty-state">Sem dados de projetos para exibir.</div>';
    if (projetosChartInstance) {
      projetosChartInstance.destroy();
      projetosChartInstance = null;
    }
    return;
  }

  // Garante canvas
  let canvas = document.getElementById("projetosChart");
  if (!canvas) {
    tabProjetos.innerHTML = "";
    const wrapper = document.createElement("div");
    wrapper.id = "projetosChartWrapper";

    canvas = document.createElement("canvas");
    canvas.id = "projetosChart";

    wrapper.appendChild(canvas);
    tabProjetos.appendChild(wrapper);
  }

  // Monta datasets: maior atrás, menor na frente, cores por tipo
  const dataMaior = [];
  const dataMenor = [];
  const bgMaior   = [];
  const bgMenor   = [];

  const COR_ATUAL = "#2196F3";
  const COR_PROJ  = "#FF9800";

  todosProjetos.forEach(projeto => {
    const hasAtual = Object.prototype.hasOwnProperty.call(lucrosAtuaisMap, projeto);
    const hasProj  = Object.prototype.hasOwnProperty.call(projecoesProjetos, projeto);

    const lucroAtual = hasAtual ? lucrosAtuaisMap[projeto] : null;
    const lucroProj  = hasProj  ? projecoesProjetos[projeto] : null;

    // Nenhum dado (não deveria acontecer)
    if (!hasAtual && !hasProj) {
      dataMaior.push(null);
      bgMaior.push("transparent");
      dataMenor.push(null);
      bgMenor.push("transparent");
      return;
    }

    // Ambos existem -> maior atrás, menor na frente
    if (hasAtual && hasProj) {
      const absAtual = Math.abs(lucroAtual);
      const absProj  = Math.abs(lucroProj);

      let valMaior, valMenor, corMaior, corMenor;

      if (absAtual > absProj) {
        // Atual maior
        valMaior = lucroAtual;
        corMaior = COR_ATUAL;

        valMenor = lucroProj;
        corMenor = COR_PROJ;
      } else if (absProj > absAtual) {
        // Projeção maior
        valMaior = lucroProj;
        corMaior = COR_PROJ;

        valMenor = lucroAtual;
        corMenor = COR_ATUAL;
      } else {
        // Iguais -> critério fixo:
        // atual = barra de trás (mais larga), projeção = barra da frente (mais estreita)
        valMaior = lucroProj;
        corMaior = COR_PROJ;

        valMenor = lucroAtual;
        corMenor = COR_ATUAL;
      }

      dataMaior.push(valMaior);
      bgMaior.push(corMaior);

      dataMenor.push(valMenor);
      bgMenor.push(corMenor);
    }
    // Só atual
    else if (hasAtual) {
      dataMaior.push(null);
      bgMaior.push("transparent");
      dataMenor.push(lucroAtual);
      bgMenor.push(COR_ATUAL);
    }
    // Só projeção
    else if (hasProj) {
      dataMaior.push(null);
      bgMaior.push("transparent");
      dataMenor.push(lucroProj);
      bgMenor.push(COR_PROJ);
    }
  });

  const smallWidth = window.innerWidth < 480;

  loadChartJs(() => {
    const ctx = canvas.getContext("2d");

    if (projetosChartInstance) {
      projetosChartInstance.destroy();
    }

    projetosChartInstance = new Chart(ctx, {
      type: "bar",
      data: {
        labels: todosProjetos,
        datasets: [
          // Maior valor (sempre atrás)
          {
            label: "Maior",
            data: dataMaior,
            backgroundColor: bgMaior,
            borderWidth: 0,
            grouped: false,      // <- impede barras lado a lado
            barPercentage: 1.0,    // largura da barra "de fundo"
            order: 1             // desenha primeiro (fica atrás)
          },
          // Menor valor: barra mais estreita e na frente
          {
            label: "Menor",
            data: dataMenor,
            backgroundColor: bgMenor,
            borderWidth: 0,
            grouped: false,      // <- mesma posição no eixo X
            barPercentage: 0.93,    // mais fina, aparece "dentro" da maior
            order: 0             // desenha depois (fica na frente)
          },
          // Legenda: Lucro atual
          {
            label: "Lucro atual",
            data: [],
            backgroundColor: COR_ATUAL,
            borderWidth: 0
          },
          // Legenda: Lucro projetado
          {
            label: "Lucro projetado",
            data: [],
            backgroundColor: COR_PROJ,
            borderWidth: 0
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: true,
            labels: {
              // Só mostra os dois últimos datasets na legenda
              filter: (legendItem) => legendItem.datasetIndex >= 2
            }
          },
          tooltip: {
            // mostra tooltip só para as barras reais (Maior e Menor),
            // ignora os datasets usados só pra legenda
            filter: function(ctx) {
              return ctx.datasetIndex === 0 || ctx.datasetIndex === 1;
            },
            callbacks: {
              label: function(context) {
                const valor = context.parsed.y || 0;

                // descobre a cor real da barra neste índice
                let bg = context.dataset.backgroundColor;
                if (Array.isArray(bg)) {
                  bg = bg[context.dataIndex];
                }

                let tipo = "";
                if (bg === COR_ATUAL) {
                  tipo = "Lucro atual";
                } else if (bg === COR_PROJ) {
                  tipo = "Lucro projetado";
                }

                return (tipo ? tipo + ": " : "") + formatarValor(valor);
              }
            }
          }
        },
        scales: {
          x: {
            ticks: {
              maxRotation: 45,
              minRotation: 0,
            }
          },
          y: {
            beginAtZero: true,
            ticks: {
              display: !smallWidth, // esconde textos do eixo Y se largura < 480
              callback: function(value) {
                return formatarValor(value);
              }
            },
            grid: {
              display: !smallWidth
            }
          }
        }
      }
    });
  });
}



function atualizarGraficoProjecao() {
  const tabProjecao = document.getElementById("tab-projecao");
  if (!tabProjecao) return;

  if (!projecaoSeries || projecaoSeries.length === 0) {
    tabProjecao.innerHTML = '<div class="empty-state">Sem dados de projeção para exibir.</div>';
    if (projecaoChartInstance) {
      projecaoChartInstance.destroy();
      projecaoChartInstance = null;
    }
    return;
  }

  // --- aplica filtro de ano (a partir do ano selecionado) ---
  const filterAnoSelect = document.getElementById("filter-ano");
  const filtroAno = filterAnoSelect ? filterAnoSelect.value : "";

  let seriesFiltrada = projecaoSeries;

  if (filtroAno) {
    const anoSel = parseInt(filtroAno, 10);
    if (!isNaN(anoSel)) {
      seriesFiltrada = projecaoSeries.filter(p => {
        const dt = parseDataString(p.data);
        return dt && dt.getFullYear() >= anoSel;
      });
    }
  }

  if (!seriesFiltrada.length) {
    tabProjecao.innerHTML = '<div class="empty-state">Sem dados de projeção para o ano selecionado.</div>';
    if (projecaoChartInstance) {
      projecaoChartInstance.destroy();
      projecaoChartInstance = null;
    }
    return;
  }

  // --- garante container + canvas ---
  let canvas = document.getElementById("projecaoChart");
  if (!canvas) {
    tabProjecao.innerHTML = "";

    const wrapper = document.createElement("div");
    wrapper.id = "projecaoChartWrapper";

    canvas = document.createElement("canvas");
    canvas.id = "projecaoChart";

    wrapper.appendChild(canvas);
    tabProjecao.appendChild(wrapper);
  }

  // --- prepara dados ---
  const labels  = seriesFiltrada.map(p => p.data);
  const valores = seriesFiltrada.map(p => p.valor);

  const hoje = new Date();
  hoje.setHours(0, 0, 0, 0);

  const isFutureFlags = labels.map(dataStr => {
    const dt = parseDataString(dataStr);
    return dt && dt > hoje; // futuro = pontilhado
  });

  // --- breakpoints responsivos para o gráfico ---
  const smallHeight = window.innerHeight < 480;
  const smallWidth  = window.innerWidth  < 480;

  loadChartJs(() => {
    const ctx = canvas.getContext("2d");

    if (projecaoChartInstance) {
      projecaoChartInstance.destroy();
    }

    projecaoChartInstance = new Chart(ctx, {
      type: "line",
      data: {
        labels: labels,
        datasets: [
          // Dataset REAL: linha única; futuro fica pontilhado
          {
            label: "Balanço",
            data: valores,
            borderColor: "#2196F3",
            backgroundColor: "#2196F3",
            tension: 0.25,
            spanGaps: false,
            pointRadius: 6,
            pointHoverRadius: 10,
            segment: {
              borderDash: ctx => {
                const idx = ctx.p1DataIndex;
                return isFutureFlags[idx] ? [5, 5] : undefined;
              }
            }
          },
          // LEGEND: Histórico (linha cheia)
          {
            label: "Histórico",
            data: [NaN],
            borderColor: "#2196F3",
            borderDash: [],
            borderWidth: 3,
            fill: false,
            pointRadius: 0
          },
          // LEGEND: Projeção (pontilhada)
          {
            label: "Projeção",
            data: [NaN],
            borderColor: "#2196F3",
            borderDash: [5, 10],
            borderWidth: 3,
            fill: false,
            pointRadius: 0
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          // legenda some em telas com pouca altura
          legend: {
            display: !smallHeight,
            labels: {
              filter: (legendItem) => legendItem.datasetIndex !== 0,
              boxWidth: 40,
              boxHeight: 0
            }
          },
          // tooltip só no dataset real
          tooltip: {
            filter: (ctx) => ctx.datasetIndex === 0,
            callbacks: {
              title: function(items) {
                const raw = items[0].label || "";
                const dt = parseDataString(raw);
                if (!dt) return raw;
                const mes = MESES_CURTOS[dt.getMonth()];
                return `${mes}/${dt.getFullYear()}`;
              },
              label: function(context) {
                const v = context.parsed.y || 0;
                return formatarValor(v);
              }
            }
          }
        },
        scales: {
          x: {
            // esconde textos do eixo X se altura < 480
            ticks: {
              display: !smallHeight,
              callback: function(value) {
                const raw = this.getLabelForValue(value);
                const dt = parseDataString(raw);
                if (!dt) return "";
                const mes = MESES_CURTOS[dt.getMonth()];
                return `${mes}/${dt.getFullYear()}`;
              },
              maxRotation: 45,
              minRotation: 0,
            },
            grid: {
              display: !smallHeight
            }
          },
          y: {
            beginAtZero: false,
            // esconde textos do eixo Y se largura < 480
            ticks: {
              display: !smallWidth,
              callback: function(value) {
                return formatarValor(value);
              }
            },
            grid: {
              display: !smallWidth
            }
          }
        }
      }
    });
  });
}


window.addEventListener("resize", () => {
  if (projecaoSeries && projecaoSeries.length) {
    atualizarGraficoProjecao();
  }
  if ((entradas && entradas.length) || (saidas && saidas.length)) {
    atualizarGraficoProjetos();
  }
});


</script>
